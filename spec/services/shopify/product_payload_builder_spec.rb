# frozen_string_literal: true

require 'rails_helper'

RSpec.describe Shopify::ProductPayloadBuilder do
  include ActiveSupport::Testing::TimeHelpers

  describe '#product_payload' do
    subject(:builder) { described_class.new(product) }

    let(:store) { create(:store) }
    let(:manufacturer) { create(:manufacturer, name: 'Nike', store: store) }
    let(:category) { create(:category, name: 'Sports', store: store) }
    let(:product) do
      create(:product,
             name: 'Running Shoes',
             quantity: 10,
             manufacturer: manufacturer,
             category: category,
             manufacturer_sku: 'NIKE-123',
             sku: 'SKU-123',
             amount_cents: 9999,
             store: store)
    end

    describe 'product_payload structure' do
      let(:payload) { builder.product_payload }

      it 'returns a hash with all required fields' do
        expect(payload).to be_a(Hash)
        expect(payload).to include(:title, :status, :vendor, :product_type, :tags, :published_scope, :published_at, :images)
      end

      it 'sets the title from product name' do
        expect(payload[:title]).to eq('Running Shoes')
      end

      it 'sets status to active when quantity is positive' do
        product.update(quantity: 5)
        expect(payload[:status]).to eq(:active)
      end

      it 'sets status to draft when quantity is zero' do
        product.update(quantity: 0)
        expect(payload[:status]).to eq(:draft)
      end

      it 'sets vendor from manufacturer name' do
        expect(payload[:vendor]).to eq('Nike')
      end

      it 'sets vendor to "Unknown" when manufacturer is nil' do
        product.update(manufacturer: nil)
        expect(payload[:vendor]).to eq('Unknown')
      end

      it 'sets product_type from category name' do
        expect(payload[:product_type]).to eq('Sports')
      end

      it 'sets product_type to "Uncategorized" when category is nil' do
        product.update(category: nil)
        expect(payload[:product_type]).to eq('Uncategorized')
      end

      it 'includes tags generated by ProductTagBuilder' do
        expect(payload[:tags]).to be_an(Array)
        expect(payload[:tags]).to include('stock:in-stock')
        expect(payload[:tags]).to include('manufacturer:nike')
      end

      it 'sets published_scope to global' do
        expect(payload[:published_scope]).to eq(:global)
      end

      it 'sets published_at to current datetime in ISO8601 format' do
        travel_to Time.zone.parse('2024-01-15 10:00:00') do
          payload = builder.product_payload
          expect(payload[:published_at]).to eq(DateTime.parse('2024-01-15 10:00:00').iso8601)
        end
      end

      it 'includes images array' do
        expect(payload[:images]).to be_an(Array)
      end
    end

    describe 'with images attached' do
      let(:payload) { builder.product_payload }

      before do
        product.images.attach(
          io: StringIO.new('fake image content'),
          filename: 'test.jpg',
          content_type: 'image/jpeg'
        )
      end

      it 'includes image attachments' do
        expect(payload[:images]).not_to be_empty
        expect(payload[:images].first).to have_key(:attachment)
      end

      it 'encodes images in base64' do
        attachment = payload[:images].first[:attachment]
        expect(attachment).to be_a(String)
        expect { Base64.strict_decode64(attachment) }.not_to raise_error
      end
    end

    describe 'with multiple images' do
      let(:payload) { builder.product_payload }

      before do
        2.times do |i|
          product.images.attach(
            io: StringIO.new("fake image #{i}"),
            filename: "test#{i}.jpg",
            content_type: 'image/jpeg'
          )
        end
      end

      it 'includes all images' do
        expect(payload[:images].size).to eq(2)
      end
    end

    describe 'when image processing fails' do
      before do
        product.images.attach(
          io: StringIO.new('fake image'),
          filename: 'test.jpg',
          content_type: 'image/jpeg'
        )

        # Stub the download method on the specific attached image
        attached_image = product.images.attachments.first
        allow(attached_image.blob).to receive(:download).and_raise(StandardError, 'Download failed')
      end

      it 'logs the error and excludes failed images' do
        allow(Rails.logger).to receive(:error)
        images = builder.send(:product_images)
        expect(images).to be_empty
        expect(Rails.logger).to have_received(:error).with(/Failed to process image/)
      end
    end

    describe 'variant_payload structure' do
      let(:payload) { builder.variant_payload }

      it 'returns a hash with all required fields' do
        expect(payload).to be_a(Hash)
        expect(payload).to include(:sku, :barcode, :inventory_management, :price)
      end

      it 'sets sku from manufacturer_sku' do
        expect(payload[:sku]).to eq('NIKE-123')
      end

      it 'sets barcode from product sku' do
        expect(payload[:barcode]).to eq('SKU-123')
      end

      it 'sets inventory_management to shopify' do
        expect(payload[:inventory_management]).to eq(:shopify)
      end

      it 'converts price from cents to decimal' do
        product.update(amount_cents: 10_000)
        expect(payload[:price]).to eq(100.0)
      end

      it 'handles zero price' do
        product.update(amount_cents: 0)
        expect(payload[:price]).to eq(0.0)
      end

      it 'handles nil amount_cents by defaulting to 0' do
        allow(product).to receive(:amount_cents).and_return(nil)
        expect(payload[:price]).to eq(0.0)
      end

      it 'correctly converts fractional prices' do
        product.update(amount_cents: 1999)
        expect(payload[:price]).to eq(19.99)
      end

      it 'allows nil barcode' do
        product.update(sku: nil)
        expect(payload[:barcode]).to be_nil
      end
    end

    describe 'product status logging' do
      it 'logs active status when quantity is positive' do
        allow(Rails.logger).to receive(:info)
        product.update(quantity: 10)
        builder.product_payload
        expect(Rails.logger).to have_received(:info).with(/Setting Shopify status for product_id=#{product.id}: active \(quantity=10\)/)
      end

      it 'logs draft status when quantity is zero' do
        allow(Rails.logger).to receive(:info)
        product.update(quantity: 0)
        builder.product_payload
        expect(Rails.logger).to have_received(:info).with(/Setting Shopify status for product_id=#{product.id}: draft \(quantity=0\)/)
      end
    end

    describe 'image processing logging' do
      it 'logs image processing start' do
        allow(Rails.logger).to receive(:info)
        builder.product_payload
        expect(Rails.logger).to have_received(:info).with(/Processing .* product images for product_id=#{product.id}/)
      end
    end

    describe 'edge cases' do
      it 'handles product with no manufacturer name' do
        manufacturer.update(name: nil)
        payload = builder.product_payload
        expect(payload[:vendor]).to eq('Unknown')
      end

      it 'handles product with no category name' do
        category.update(name: nil)
        payload = builder.product_payload
        expect(payload[:product_type]).to eq('Uncategorized')
      end

      it 'handles negative quantity' do
        product.update(quantity: -5)
        payload = builder.product_payload
        expect(payload[:status]).to eq(:draft)
      end

      it 'handles very large prices' do
        product.update(amount_cents: 999_999_99)
        payload = builder.variant_payload
        expect(payload[:price]).to eq(999_999.99)
      end
    end
  end
end
